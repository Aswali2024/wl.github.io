<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>新油吸</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 30px;
            background: rgba(255, 255, 255, 0.3);
            padding: 10px;
            border-radius: 20px;
        }
        input, button, select {
            margin: 5px 0;
            padding: 5px;
        }
        #fps {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 50px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="number" id="mass" placeholder="质量 (kg)" value="1">
        <input type="number" id="velocity" placeholder="速度 (m/s)" value="5">
        <input type="number" id="quantity" placeholder="数量" value="1" min="1">
        <select id="shape">
            <option value="square">方形</option>
            <option value="circle">圆形</option>
            <option value="rectangle">长方形</option>
            <option value="polygon">多边形</option>
            <option value="triangle">三角形</option>
            <option value="softHuman">软体小人</option>
            <option value="cross">圆滑方形</option>
            <option value="humanShape">人</option> 
            <option value="car">车辆</option>
            <option value="train">火车</option>       
        <input type="number" id="explosionForce" placeholder="爆炸威力" value="0.0001">
        <button id="applyChanges">应用更改</button>
    </div>
    <div id="fps">FPS: 0</div>
    <script>
        const Engine = Matter.Engine,
              Render = Matter.Render,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Vertices = Matter.Vertices,
              Body = Matter.Body,
              Constraint = Matter.Constraint,
              Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false
            }
        });

        Render.run(render);
        Engine.run(engine);

        // 创建地面
        const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight, window.innerWidth, 60, { isStatic: true });
        World.add(world, ground);

        // 创建墙壁
        const leftWall = Bodies.rectangle(0, window.innerHeight / 2, 60, window.innerHeight, { isStatic: true });
        const rightWall = Bodies.rectangle(window.innerWidth, window.innerHeight / 2, 60, window.innerHeight, { isStatic: true });
        World.add(world, [leftWall, rightWall]);

        // 鼠标控制
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });
        World.add(world, mouseConstraint);

        render.mouse = mouse;
        // 创建软体小人
        function createSoftHuman(x, y, scale = 1) {
            const group = Body.nextGroup(true);
            const color = getRandomColor();

            const head = Bodies.circle(x, y - 50 * scale, 20 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const torso = Bodies.rectangle(x, y, 40 * scale, 60 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const leftArm = Bodies.rectangle(x - 30 * scale, y - 10 * scale, 40 * scale, 10 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const rightArm = Bodies.rectangle(x + 30 * scale, y - 10 * scale, 40 * scale, 10 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const leftLeg = Bodies.rectangle(x - 15 * scale, y + 50 * scale, 10 * scale, 40 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const rightLeg = Bodies.rectangle(x + 15 * scale, y + 50 * scale, 10 * scale, 40 * scale, {
                collisionFilter: { group: group },
                render: { fillStyle: color }
            });

            const neckJoint = Constraint.create({
                bodyA: head,
                bodyB: torso,
                pointA: { x: 0, y: 20 * scale },
                pointB: { x: 0, y: -30 * scale },
                stiffness: 0.5,
                render: { visible: false }
            });

            const leftShoulderJoint = Constraint.create({
                bodyA: torso,
                bodyB: leftArm,
                pointA: { x: -20 * scale, y: -25 * scale },
                pointB: { x: 20 * scale, y: 0 },
                stiffness: 0.5,
                render: { visible: false }
            });

            const rightShoulderJoint = Constraint.create({
                bodyA: torso,
                bodyB: rightArm,
                pointA: { x: 20 * scale, y: -25 * scale },
                pointB: { x: -20 * scale, y: 0 },
                stiffness: 0.5,
                render: { visible: false }
            });

            const leftHipJoint = Constraint.create({
                bodyA: torso,
                bodyB: leftLeg,
                pointA: { x: -15 * scale, y: 30 * scale },
                pointB: { x: 0, y: -20 * scale },
                stiffness: 0.5,
                render: { visible: false }
            });

            const rightHipJoint = Constraint.create({
                bodyA: torso,
                bodyB: rightLeg,
                pointA: { x: 15 * scale, y: 30 * scale },
                pointB: { x: 0, y: -20 * scale },
                stiffness: 0.5,
                render: { visible: false }
            });

            const human = Composite.create({
                bodies: [head, torso, leftArm, rightArm, leftLeg, rightLeg],
                constraints: [neckJoint, leftShoulderJoint, rightShoulderJoint, leftHipJoint, rightHipJoint]
            });

            return human;
        }
                // 创建车辆
                function createCar(x, y) {
            const group = Body.nextGroup(true);
            const wheelBase = 100;
            const wheelAOffset = -50;
            const wheelBOffset = 50;
            const wheelYOffset = 30;
            const wheelRadius = 30;

            const car = Composite.create({ label: 'Car' });
            const body = Bodies.rectangle(x, y, 200, 50, { 
                collisionFilter: { group: group },
                chamfer: { radius: 10 },
                density: 0.0002
            });

            const wheelA = Bodies.circle(x + wheelAOffset, y + wheelYOffset, wheelRadius, { 
                collisionFilter: { group: group },
                friction: 0.8
            });

            const wheelB = Bodies.circle(x + wheelBOffset, y + wheelYOffset, wheelRadius, { 
                collisionFilter: { group: group },
                friction: 0.8
            });

            const axelA = Constraint.create({
                bodyB: body,
                pointB: { x: wheelAOffset, y: wheelYOffset },
                bodyA: wheelA,
                stiffness: 1,
                length: 0
            });

            const axelB = Constraint.create({
                bodyB: body,
                pointB: { x: wheelBOffset, y: wheelYOffset },
                bodyA: wheelB,
                stiffness: 1,
                length: 0
            });

            Composite.addBody(car, body);
            Composite.addBody(car, wheelA);
            Composite.addBody(car, wheelB);
            Composite.addConstraint(car, axelA);
            Composite.addConstraint(car, axelB);

            return car;
        }
        // 创建新物体
        render.canvas.addEventListener('click', (event) => {
            if (!mouseConstraint.body) {
                const mass = parseFloat(document.getElementById('mass').value) || 1;
                const velocity = parseFloat(document.getElementById('velocity').value) || 5;
                const quantity = parseInt(document.getElementById('quantity').value) || 1;
                const shape = document.getElementById('shape').value;
                
                for (let i = 0; i < quantity; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    let body;
                    if (shape === 'circle') {
                        body = Bodies.circle(event.clientX + offsetX, event.clientY + offsetY, 20, {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                    } else if (shape === 'square') {
                        body = Bodies.rectangle(event.clientX + offsetX, event.clientY + offsetY, 40, 40, {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                    } else if (shape === 'triangle') {
                        const triangleVertices = Vertices.fromPath('0 0 40 0 20 34.64');
                        body = Bodies.fromVertices(event.clientX + offsetX, event.clientY + offsetY, triangleVertices, {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                    } else if (shape === 'rectangle') {
                        body = Bodies.rectangle(event.clientX + offsetX, event.clientY + offsetY, 60, 30, {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                    } else if (shape === 'softHuman') {
                        body = createSoftHuman(event.clientX + offsetX, event.clientY + offsetY, 0.5);
                        Composite.add(world, body);
                        Composite.allBodies(body).forEach(part => {
                            Body.setMass(part, mass / 6);
                            Body.setVelocity(part, { x: velocity, y: 0 });
                        });
                        continue;
                    } else if (shape === 'car') {
                        body = createCar(event.clientX + offsetX, event.clientY + offsetY);
                        Composite.add(world, body);
                        Composite.allBodies(body).forEach(part => {
                            Body.setMass(part, mass / 3);
                            Body.setVelocity(part, { x: velocity, y: 0 });
                        });
                        continue;
                    } else if (shape === 'polygon') {
                        const sides = 5; // 可以根据需要调整边数
                        const radius = 30;
                        body = Bodies.polygon(event.clientX + offsetX, event.clientY + offsetY, sides, radius, {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                    } else if (shape === 'cross') {
                        const size = 40;
                        const thickness = 10;
                        const crossShape = [
                            {x: 0, y: -size/2}, {x: -thickness/2, y: -size/2},
                            {x: -thickness/2, y: -thickness/2}, {x: -size/2, y: -thickness/2},
                            {x: -size/2, y: thickness/2}, {x: -thickness/2, y: thickness/2},
                            {x: -thickness/2, y: size/2}, {x: thickness/2, y: size/2},
                            {x: thickness/2, y: thickness/2}, {x: size/2, y: thickness/2},
                            {x: size/2, y: -thickness/2}, {x: thickness/2, y: -thickness/2},
                            {x: thickness/2, y: -size/2}, {x: 0, y: -size/2}
                        ];    
                        body = Bodies.fromVertices(event.clientX + offsetX, event.clientY + offsetY, [crossShape], {
                            mass: mass,
                            restitution: 0.5,
                            friction: 0.005,
                            render: {
                                fillStyle: getRandomColor()
                            }
                        });
                        //人形状
                    } else if (shape === 'humanShape') {
                            const headRadius = 15;
                            const bodyWidth = 30;
                            const bodyHeight = 60;
                            const legWidth = 10;
                            const legHeight = 40;
                            const armWidth = 10;
                            const armHeight = 30;
                                const head = Bodies.circle(event.clientX + offsetX, event.clientY + offsetY - bodyHeight / 2 - headRadius, headRadius);
                                const torso = Bodies.rectangle(event.clientX + offsetX, event.clientY + offsetY, bodyWidth, bodyHeight);
                                const leftLeg = Bodies.rectangle(event.clientX + offsetX - bodyWidth / 4, event.clientY + offsetY + bodyHeight / 2 + legHeight / 2, legWidth, legHeight);
                                const rightLeg = Bodies.rectangle(event.clientX + offsetX + bodyWidth / 4, event.clientY + offsetY + bodyHeight / 2 + legHeight / 2, legWidth, legHeight);
                                const leftArm = Bodies.rectangle(event.clientX + offsetX - bodyWidth / 2 - armWidth / 2, event.clientY + offsetY - bodyHeight / 4, armWidth, armHeight);
                                const rightArm = Bodies.rectangle(event.clientX + offsetX + bodyWidth / 2 + armWidth / 2, event.clientY + offsetY - bodyHeight / 4, armWidth, armHeight);

                                    const humanShape = Body.create({
                                        parts: [head, torso, leftLeg, rightLeg, leftArm, rightArm],
                                        mass: mass,
                                        restitution: 0.5,
                                        friction: 0.005,
                                        render: {
                                            fillStyle: getRandomColor()
                                        }
                                    });
                                        body = humanShape;
                            //火车形状
                    } else if (shape === 'train') {
                        const trainWidth = 120;
                        const trainHeight = 60;
                        const wheelRadius = 15;
                            const smokeStackHeight = 30;
                            const smokeStackWidth = 20;

                                const trainBody = Bodies.rectangle(event.clientX + offsetX, event.clientY + offsetY, trainWidth, trainHeight);
                                const frontWheel = Bodies.circle(event.clientX + offsetX - trainWidth/4, event.clientY + offsetY + trainHeight/2 + wheelRadius, wheelRadius);
                                const backWheel = Bodies.circle(event.clientX + offsetX + trainWidth/4, event.clientY + offsetY + trainHeight/2 + wheelRadius, wheelRadius);
                                const smokeStack = Bodies.rectangle(event.clientX + offsetX - trainWidth/3, event.clientY + offsetY - trainHeight/2 - smokeStackHeight/2, smokeStackWidth, smokeStackHeight);

                                    const trainShape = Body.create({
                                        parts: [trainBody, frontWheel, backWheel, smokeStack],
                                        mass: mass,
                                        restitution: 0.5,
                                        friction: 0.005,
                                            render: {
                                                fillStyle: getRandomColor()
                                        }
                                });
                                    body = trainShape;
                    }                                                        
                    if (body) {
                        Matter.Body.setVelocity(body, { x: velocity, y: 0 });
                        World.add(world, body);
                    }
                }
            }
        });

        // 爆炸功能
        render.canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            const explosionForce = parseFloat(document.getElementById('explosionForce').value) || 0.1;
            const bodies = Composite.allBodies(world);
            const explosionPoint = { x: event.clientX, y: event.clientY };

            bodies.forEach((body) => {
                if (!body.isStatic) {
                    const force = {
                        x: (body.position.x - explosionPoint.x) * explosionForce,
                        y: (body.position.y - explosionPoint.y) * explosionForce
                    };
                    Body.applyForce(body, body.position, force);
                }
            });
        });
        // 长按鼠标中键实现排斥力
            let middleMousePressed = false;
            let repulsionInterval;

            render.canvas.addEventListener('mousedown', (event) => {
                if (event.button === 1) { // 中键
                    event.preventDefault();
                    middleMousePressed = true;
                    applyRepulsionForce(event);
                    repulsionInterval = setInterval(() => applyRepulsionForce(event), 100);
                }
            });

            render.canvas.addEventListener('mouseup', (event) => {
                if (event.button === 1) {
                    middleMousePressed = false;
                    clearInterval(repulsionInterval);
                }
            });

            render.canvas.addEventListener('mousemove', (event) => {
                if (middleMousePressed) {
                    applyRepulsionForce(event);
                }
            });

            function applyRepulsionForce(event) {
                const repulsionForce = 0.0003;
                const repulsionRadius = 150;
                const bodies = Composite.allBodies(world);
                const repulsionPoint = { x: event.clientX, y: event.clientY };

                bodies.forEach((body) => {
                    if (!body.isStatic) {
                        const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, repulsionPoint));
                        if (distance < repulsionRadius) {
                            const force = {
                                x: (body.position.x - repulsionPoint.x) * repulsionForce,
                                y: (body.position.y - repulsionPoint.y) * repulsionForce
                            };
                            Body.applyForce(body, body.position, force);
                        }
                    }
                });
            }
        // 按I添加一个由刚体组成的房子
            function createHouse(x, y) {
                const wallThickness = 20;
                const roofHeight = 100;
                const houseWidth = 200;
                const houseHeight = 200;

                const house = Composite.create();

                // 左墙
                Composite.add(house, Bodies.rectangle(x - houseWidth / 2 + wallThickness / 2, y, wallThickness, houseHeight, { isStatic: false, friction: 0.5, restitution: 0.2, isClearable: true }));
                // 右墙
                Composite.add(house, Bodies.rectangle(x + houseWidth / 2 - wallThickness / 2, y, wallThickness, houseHeight, { isStatic: false, friction: 0.5, restitution: 0.2, isClearable: true }));
                // 地板
                Composite.add(house, Bodies.rectangle(x, y + houseHeight / 2 - wallThickness / 2, houseWidth, wallThickness, { isStatic: false, friction: 0.5, restitution: 0.2, isClearable: true }));
                // 屋顶
                Composite.add(house, Bodies.rectangle(x, y - houseHeight / 2 - wallThickness / 2, houseWidth, wallThickness, { isStatic: false, friction: 0.5, restitution: 0.2, isClearable: true }));
                                
                return house;
            }
            // 监听键盘事件，按I键快速生成房子
            document.addEventListener('keydown', (event) => {
                if (event.key === 'i' || event.key === 'I') {
                    const house = createHouse(
                        Math.random() * (render.options.width - 200) + 100,
                        Math.random() * (render.options.height - 300) + 150
                    );
                    Composite.add(world, house);
                }
            });        
        //长按T键可以实现黑洞吸引效果
            let tKeyPressed = false;
            let blackHoleInterval;

            document.addEventListener('keydown', (event) => {
                if (event.key === 'T' || event.key === 't') {
                    tKeyPressed = true;
                    applyBlackHoleEffect();
                    blackHoleInterval = setInterval(() => {
                        if (tKeyPressed) {
                            applyBlackHoleEffect();
                        } else {
                            clearInterval(blackHoleInterval);
                        }
                    }, 16);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'T' || event.key === 't') {
                    tKeyPressed = false;
                }
            });

            function applyBlackHoleEffect() {
                const attractionForce = 0.0000003;
                const attractionRadius = 300;
                const removalRadius = 40;
                const bodies = Composite.allBodies(world);
                const blackHolePosition = { x: render.mouse.position.x, y: render.mouse.position.y };

                bodies.forEach((body) => {
                    if (!body.isStatic) {
                        const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, blackHolePosition));
                        if (distance < attractionRadius) {
                            const force = {
                                x: (blackHolePosition.x - body.position.x) * attractionForce,
                                y: (blackHolePosition.y - body.position.y) * attractionForce
                            };
                            Body.applyForce(body, body.position, force);

                            if (distance < removalRadius) {
                                World.remove(world, body,Composite);
                            }
                        }
                    }
                });
            }
        //长按U可以施加向上的力
            let uKeyPressed = false;
            let upwardForceInterval;

            document.addEventListener('keydown', (event) => {
                if (event.key === 'U' || event.key === 'u') {
                    uKeyPressed = true;
                    applyUpwardForce();
                    upwardForceInterval = setInterval(() => {
                        if (uKeyPressed) {
                            applyUpwardForce();
                        } else {
                            clearInterval(upwardForceInterval);
                        }
                    }, 16);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'U' || event.key === 'u') {
                    uKeyPressed = false;
                }
            });

            function applyUpwardForce() {
                const upwardForce = 0.0001;
                const forceRadius = 200;
                const bodies = Composite.allBodies(world);
                const mousePosition = render.mouse.position;

                bodies.forEach((body) => {
                    if (!body.isStatic) {
                        const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, mousePosition));
                        if (distance < forceRadius) {
                            const force = {
                                x: 0,
                                y: -upwardForce
                            };
                            Body.applyForce(body, body.position, force);
                        }
                    }
                });
            }        
        //长按Y实现重力压制
            let yKeyPressed = false;
            let gravitySuppressionInterval;

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Y' || event.key === 'y') {
                    yKeyPressed = true;
                    applyGravitySuppressionEffect();
                    gravitySuppressionInterval = setInterval(() => {
                        if (yKeyPressed) {
                            applyGravitySuppressionEffect();
                        } else {
                            clearInterval(gravitySuppressionInterval);
                        }
                    }, 16);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'Y' || event.key === 'y') {
                    yKeyPressed = false;
                }
            });

            function applyGravitySuppressionEffect() {
                const suppressionForce = 0.0004;
                const suppressionRadius = 200;
                const bodies = Composite.allBodies(world);
                const mousePosition = render.mouse.position;

                bodies.forEach((body) => {
                    if (!body.isStatic) {
                        const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, mousePosition));
                        if (distance < suppressionRadius) {
                            const force = {
                                x: 0,
                                y: suppressionForce
                            };
                            Body.applyForce(body, body.position, force);
                        }
                    }
                });
            }        
        // 长按E键可以在鼠标的位置上吸引物体
            let isEKeyPressed = false;
            let attractionInterval;

            document.addEventListener('keydown', (event) => {
                if ((event.key === 'e' || event.key === 'E') && !isEKeyPressed) {
                    isEKeyPressed = true;
                    applyAttractionForce();
                    attractionInterval = setInterval(applyAttractionForce, 100);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'e' || event.key === 'E') {
                    isEKeyPressed = false;
                    clearInterval(attractionInterval);
                }
            });

            function applyAttractionForce() {
                if (!isEKeyPressed) {
                    clearInterval(attractionInterval);
                    return;
                }
                const attractionForce = 0.0004;
                const attractionRadius = 200;
                const bodies = Composite.allBodies(world);
                const mousePosition = { x: render.mouse.position.x, y: render.mouse.position.y };

                bodies.forEach((body) => {
                    if (!body.isStatic) {
                        const distance = Matter.Vector.magnitude(Matter.Vector.sub(body.position, mousePosition));
                        if (distance < attractionRadius) {
                            const force = {
                                x: (mousePosition.x - body.position.x) * attractionForce,
                                y: (mousePosition.y - body.position.y) * attractionForce
                            };
                            Body.applyForce(body, body.position, force);
                        }
                    }
                });
            }
            // 使用说明悬浮窗
                                    const instructionWindow = document.createElement('div');
                                    instructionWindow.style.position = 'fixed';
                                    instructionWindow.style.top = '10px';
                                    instructionWindow.style.right = '300px';
                                    instructionWindow.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                                    instructionWindow.style.padding = '5px';
                                    instructionWindow.style.borderRadius = '5px';
                                    instructionWindow.style.cursor = 'move';
                                    instructionWindow.style.transition = 'all 0.3s ease';
                                    instructionWindow.style.userSelect = 'none';

                                    const instructionTitle = document.createElement('h3');
                                    instructionTitle.textContent = '说明书';
                                    instructionTitle.style.margin = '0';

                                    const instructionContent = document.createElement('div');
                                    instructionContent.style.display = 'none';
                                    instructionContent.style.transition = 'max-height 1.3s ease, opacity 0.3s ease';
                                    instructionContent.style.maxHeight = '0';
                                    instructionContent.style.opacity = '0';
                                    instructionContent.style.overflow = 'hidden';
                                    instructionContent.innerHTML = `
                                        <p>1.按住鼠标左键创建物体</p>
                                        <p>2.长按住鼠标中键排斥力</p>
                                        <p>3.按住鼠标右键爆炸</p>
                                        <p>4.按住 Q 键清除所有物体</p>
                                        <p>5.按住 W 键创建障碍物</p>
                                        <p>6.长按 E 键吸引物体</p>
                                        <p>7.长按 R 键快速创建物体</p>
                                        <p>8.长按 T 键黑洞</p>
                                        <p>9.长按 左Shift 创建随机物体</p>
                                        <p>10.按 12345 切换物体配合R键</p>
                                        <p>11.长按 Y 实现重力压制</p>
                                        <p>12.长按 U 原地升天</p>
                                        <p>13.按 I 快速创建房子</p>
                                    `;

                                    instructionWindow.appendChild(instructionTitle);
                                    instructionWindow.appendChild(instructionContent);

                                    document.body.appendChild(instructionWindow);

                                    let isExpanded = false;
                                    let isDragging = false;
                                    let offsetX, offsetY;

                                    instructionWindow.addEventListener('mousedown', (e) => {
                                        isDragging = true;
                                        offsetX = e.clientX - instructionWindow.getBoundingClientRect().left;
                                        offsetY = e.clientY - instructionWindow.getBoundingClientRect().top;
                                    });

                                    document.addEventListener('mousemove', (e) => {
                                        if (isDragging) {
                                            const left = e.clientX - offsetX;
                                            const top = e.clientY - offsetY;
                                            instructionWindow.style.left = `${left}px`;
                                            instructionWindow.style.top = `${top}px`;
                                            instructionWindow.style.right = 'auto';
                                        }
                                    });

                                    document.addEventListener('mouseup', () => {
                                        isDragging = false;
                                    });

                                    instructionWindow.addEventListener('click', () => {
                                        if (!isDragging) {
                                            isExpanded = !isExpanded;
                                            if (isExpanded) {
                                                instructionContent.style.display = 'block';
                                                instructionWindow.style.width = '220px';
                                                setTimeout(() => {
                                                    instructionContent.style.maxHeight = '1000px';
                                                    instructionContent.style.opacity = '1';
                                                }, 10);
                                            } else {
                                                instructionContent.style.maxHeight = '0';
                                                instructionContent.style.opacity = '0';
                                                setTimeout(() => {
                                                    instructionContent.style.display = 'none';
                                                    instructionWindow.style.width = 'auto';
                                                }, 300);
                                            }
                                        }
                                    });
            // 长按R键可以在鼠标的位置上，向下发射刚体
            let isRKeyPressed = false;
            let shootInterval;
            let selectedBodyType = 'square'; // 默认选择发射形状

            document.addEventListener('keydown', (event) => {
                if ((event.key === 'r' || event.key === 'R') && !isRKeyPressed) {
                    isRKeyPressed = true;
                    shootBody();
                    shootInterval = setInterval(shootBody, 10); // 每5毫秒发射一个刚体
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'r' || event.key === 'R') {
                    isRKeyPressed = false;
                    clearInterval(shootInterval);
                }
            });

            function shootBody() {
                if (!isRKeyPressed) {
                    clearInterval(shootInterval);
                    return;
                }
                const mousePosition = { x: render.mouse.position.x, y: render.mouse.position.y };
                let body;

                switch (selectedBodyType) {
                    case 'circle':
                        body = Bodies.circle(mousePosition.x, mousePosition.y, 20, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                        break;
                    case 'square':
                        body = Bodies.rectangle(mousePosition.x, mousePosition.y, 40, 40, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                        break;
                    case 'rectangle':
                        body = Bodies.rectangle(mousePosition.x, mousePosition.y, 50, 30, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                        break;
                    case 'polygon':
                        body = Bodies.polygon(mousePosition.x, mousePosition.y, 5, 30, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                        break;
                    case 'triangle':
                        body = Bodies.polygon(mousePosition.x, mousePosition.y, 3, 30, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                        break;                   
                    default:
                        body = Bodies.circle(mousePosition.x, mousePosition.y, 10, {
                            restitution: 0.8,
                            friction: 0.005
                        });
                }
                Body.setVelocity(body, { x: 0, y: 50 }); // 向下的初始速度
                World.add(world, body);
            }
            // 添加选择刚体类型的功能
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case '1':
                        selectedBodyType = 'circle';
                        break;
                    case '2':
                        selectedBodyType = 'square';
                        break;
                    case '3':
                        selectedBodyType = 'rectangle';
                        break;
                    case '4':
                        selectedBodyType = 'polygon';
                        break;
                    case '5':
                        selectedBodyType = 'triangle';
                        break;
                }
            });            
        //按Q键清除所有物体
            document.addEventListener('keydown', function(event) {
                if (event.key === 'q' || event.key === 'Q') {
                    const bodies = Composite.allBodies(world);
                    bodies.forEach((body) => {
                        if (!body.isStatic) {
                            Composite.remove(world, body,Composite);
                        }
                    });
                }
            });
        //按W键创建障碍物
                    document.addEventListener('keydown', function(event) {
                        if (event.key === 'w' || event.key === 'W') {
                            const mousePosition = mouse.position;
                            const obstacleSize = 50;
                            const obstacle = Bodies.rectangle(
                                mousePosition.x,
                                mousePosition.y,
                                obstacleSize,
                                obstacleSize,
                                {
                                    isStatic: true,
                                    render: {
                                        fillStyle: '#808080'
                                    }
                                }
                            );
                            Composite.add(world, obstacle);
                        }
                    });
        //左Shift可以快速创建物体
            let creationSpeed = 5; // 默认创建速度（毫秒）
            let creationInterval;
            let isCreating = false;

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Shift' && event.location === KeyboardEvent.DOM_KEY_LOCATION_LEFT && !isCreating) {
                    isCreating = true;
                    createObject();
                    creationInterval = setInterval(createObject, creationSpeed);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'Shift' && event.location === KeyboardEvent.DOM_KEY_LOCATION_LEFT) {
                    isCreating = false;
                    clearInterval(creationInterval);
                }
            });

            function createObject() {
                const shapes = ['circle', 'rectangle', 'triangle', 'pentagon', 'hexagon'];
                const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
                const randomX = Math.random() * render.canvas.width;
                const randomY = Math.random() * render.canvas.height;
                const randomSize = 20 + Math.random() * 30;                
                let newBody;
                switch (randomShape) {
                    case 'circle':
                        newBody = Bodies.circle(randomX, randomY, randomSize / 2);
                        break;
                    case 'rectangle':
                        newBody = Bodies.rectangle(randomX, randomY, randomSize, randomSize);
                        break;
                    case 'triangle':
                        newBody = Bodies.polygon(randomX, randomY, 3, randomSize / 2);
                        break;
                    case 'pentagon':
                        newBody = Bodies.polygon(randomX, randomY, 5, randomSize / 2);
                        break;
                    case 'hexagon':
                        newBody = Bodies.polygon(randomX, randomY, 6, randomSize / 2);
                        break;
                }                
                World.add(world, newBody);
            }

        // 设置创建速度的函数
            function setCreationSpeed(speed) {
                creationSpeed = speed;
            }
        // 应用更改按钮
        document.getElementById('applyChanges').addEventListener('click', () => {
            const mass = parseFloat(document.getElementById('mass').value) || 1;
            const velocity = parseFloat(document.getElementById('velocity').value) || 5;
            const selectedBody = mouseConstraint.body;
            if (selectedBody) {
                Matter.Body.setMass(selectedBody, mass);
                Matter.Body.setVelocity(selectedBody, { x: velocity, y: selectedBody.velocity.y });
            }
        });

        // 生成随机颜色
        function getRandomColor() {
            return '#' + Math.floor(Math.random()*16777215).toString(16);
        }

        // 调整画布大小
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
            Matter.Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight });
            Matter.Body.setPosition(rightWall, { x: window.innerWidth, y: window.innerHeight / 2 });
        });
        // 添加一个重力滑动条来改变重力
        const gravitySlider = document.createElement('input');
        gravitySlider.type = 'range';
        gravitySlider.min = '0';
        gravitySlider.max = '2';
        gravitySlider.step = '0.1';
        gravitySlider.value = '1';
        gravitySlider.style.position = 'absolute';
        gravitySlider.style.top = '10px';
        gravitySlider.style.right = '600px';
        document.body.appendChild(gravitySlider);

        gravitySlider.addEventListener('input', (event) => {
            const gravity = parseFloat(event.target.value);
            engine.world.gravity.y = gravity;
        });
        // 创建一个滑动条来控制时间
        var slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0.1';
        slider.max = '1';
        slider.step = '0.1';
        slider.value = '1';
        slider.style.position = 'absolute';
        slider.style.top = '10px';
        slider.style.left = '950px';
        slider.style.width = '200px';
        document.body.appendChild(slider);

        slider.addEventListener('input', function() {
            engine.timing.timeScale = parseFloat(slider.value);
        });
        // 显示当前刚体数量
        const bodyCountDisplay = document.createElement('div');
        bodyCountDisplay.style.position = 'absolute';
        bodyCountDisplay.style.top = '50px';
        bodyCountDisplay.style.left = '1750px';
        bodyCountDisplay.style.color = 'white';
        bodyCountDisplay.style.fontFamily = 'Arial, sans-serif';
        bodyCountDisplay.style.fontSize = '16px';
        document.body.appendChild(bodyCountDisplay);
        function updateBodyCount() {
            const bodyCount = engine.world.bodies.length;
            bodyCountDisplay.textContent = `当前物体数量: ${bodyCount}`;
        }
        Matter.Events.on(engine, 'afterUpdate', updateBodyCount);
        // FPS 计算和显示
        const fpsElement = document.getElementById('fps');
        let frameCount = 0;
        let lastTime = performance.now();

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                fpsElement.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
            requestAnimationFrame(updateFPS);
        }
        updateFPS();
    </script>
</body>
</html>